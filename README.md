# TASK 1

1. Створіть новий командний репозиторій на основі цього шаблонного репозиторію.
   Створений вами репозиторій ви будете використовувати на всіх подальших заняттях.
2. Додайте до нього в колаборатори всіх студентів вашої групи.
3. Налаштуйте захист на гілку `main`:

   - Увімкніть опцію "Require a pull request before merging";
   - Увімкніть опцію "Automatically delete head branches".

4. Склонуйте репозиторій на локальний комп'ютер.
5. Створіть гілку під свою задачу від гілки `main` та продовжуйте в ній виконувати завдання. Після завершення завдання змержте свою гілку в гілку `main`.
6. Проєкт має базову структуру і налаштування, які ви будете розширяти.
7. В файлі `src/server.js`додайте обробку неіснуючих роутів (повертає статус 404 і відповідне повідомлення)

```code
    {
        message: "Route not found"
    }
```

# TASK 2

1. Створіть свій кластер в mongodb для колекції продуктів (`products`) та запишіть усі необхідні дані для його підключення у змінні оточення. Назви змінних візьміть із файлу `.env.example`.
2. Створіть функцію initMongoConnection в папці `db` і реалізуйте в ній підключення до бази даних за допомогою mongoose
3. В папці `src/db` створіть модель продукту `Product`, що буде включати в себе такі поля:

- name - string, required
- price - number, required
- category - string, enum('books', 'electronics', 'clothing', 'other'), required, default 'other'
- description - string, optional

Для автоматичного створення полів `createdAt` та `updatedAt`, можна використати параметр `timestamps: true` при створенні моделі. Це додає до об'єкту два поля: `createdAt` (дата створення) та `updatedAt` (дата оновлення), і їх не потрібно додавати вручну.

Імпортуйте базовий набір продуктів із файлу `src/db/products.json` до вашої бази, користуючись будь-яким UI інтерфейсом (в браузері, Mongo Compass тощо). Переконайтеся, що назва колекції в коді моделі та в візуальному інтерфейсі співпадають.

# TASK 3

1. Створіть роут GET `/products` для отримання масиву усіх продуктів.

Обробка цього роута має включати:

- Реєстрацію роута в файлі `src/routers/products.js`
- Опис контролера для цього роута в файлі `src/controllers/products.js`
- Створення сервісу в файлі `src/services/products.js`
- Відповідь сервера має містити об’єкт з наступними властивостями:
  ```code
      {
          status: 200,
          message: "Successfully found products!",
          data: <масив продуктів>
      }
  ```

# TASK 4

Створіть роут GET `/products/:productId` для отримання даних одного продукту по його ідентифікатору.

Обробка цього роута має включати:

- Реєстрацію роута в файлі `src/routers/products.js`
- Опис контролера для цього роута в файлі `src/controllers/products.js`
- Створення сервісу в файлі `src/services/products.js`
- Якщо за переданим ідентифікатором продукт було знайдено, то відповідь сервера має містити об’єкт з наступними властивостями:

```code
   {
       status: 200,
       message: "Successfully found product with id {productId}!",
       data: <об'єкт продукту>
   }
```

- Додайте перевірку чи продукт за переданим ідентифікатором було знайдено. Якщо продукт не було знайдено, то поверніть відповідь зі сатусом 404 і наступним об’єктом:

```code
   {
       message: "Product not found"
   }
```

# TASK 5\* (додаткове завдання)

Створіть роут POST `/products` для створення нового продукту. Тіло запиту має в себе включати наступні властивості:

- name - обов’язково;
- price - обов’язково;
- category - обов’язково;
- description - не обов’язково;

Обробка цього роута має включати:

- Реєстрацію роута в файлі `src/routers/products.js`
- Опис контролера для цього роута в файлі `src/controllers/products.js`
- Створення сервісу в файлі `src/services/products.js`
- При вдалому запиті відповідь сервера має містити об’єкт з наступними властивостями:

```code
   {
       status: 201,
       message: "Successfully created a product!",
       data: <об'єкт створеного продукту>
   }
```

# TASK 6\* (додаткове завдання)

Створіть роут PATCH `/products/:productId` для оновлення даних одного продукту по його ідентифікатору. Тіло запиту має в себе включати наступні властивості:

- name - не обов’язково;
- price - не обов’язково;
- category - не обов’язково;
- description - не обов’язково;

Обробка цього роута має включати:

- Реєстрацію роута в файлі `src/routers/products.js`
- Опис контролера для цього роута в файлі `src/controllers/products.js`
- Створення сервісу в файлі `src/services/products.js`
- Якщо за переданим ідентифікатором продукт було знайдено, то відповідь сервера має містити об’єкт з наступними властивостями:

```code
   {
       status: 200,
       message: "Successfully patched a product!",
       data: <оновлений об'єкт продукту>
   }
```

- Додайте перевірку чи продукт за переданим ідентифікатором було знайдено. Якщо продукт не було знайдено, то поверніть відповідь зі сатусом 404 і наступним об’єктом:

```code
   {
       message: "Product not found"
   }
```

# TASK 7\* (додаткове завдання)

Створіть роут DELETE `/products/:productId` для видалення одного продукту по його ідентифікатору.

Обробка цього роута має включати:

- Реєстрацію роута в файлі `src/routers/products.js`
- Опис контролера для цього роута в файлі `src/controllers/products.js`
- Створення сервісу в файлі `src/services/products.js`
- Відповідь сервера, в разі успішного видалення продукту, має бути зі статусом 204 без тіла відповіді

- Додайте перевірку чи продукт за переданим ідентифікатором було знайдено. Якщо продукт не було знайдено, , то поверніть відповідь зі сатусом 404 і наступним об’єктом:

```code
   {
       message: "Product not found"
   }
```

TASK 1
Валідація вхідних даних
Додайте валідацію вхідних даних (body) для маршрутів POST і PATCH, згідно властивостей, описаних в моделі MongoDB. Створіть для цього middleware validateBody.

Валідація id
Додайте валідацію ідентифікатора, створивши middleware для перевірки валідності ID, згідно зі схемою Mongoose.

TASK 2
Додайте можливість фільтрації продуктів за категорією (властивість category) та за ціною (властивість price) у відповіді для маршруту GET /products. Для цього використовуйте такі query параметри запиту:

category - назва категорії
minPrice - мінімільна ціна продукту
maxPrice - максимальна ціна продукту

TASK 3
Створіть модель користувача User з такими полями:

name - string, required
email - string, email, unique, required
password - string, required

Створіть модель сесії Session з такими полями:

userId - string, required
accessToken - string, required
refreshToken - string, required
accessTokenValidUntil - Date, required
refreshTokenValidUntil - Date, required

Створіть роут POST /users/register для реєстрації нового користувача. Тіло запиту має в себе включати наступні властивості:

name - обов’язково
email - обов’язково
password - обов’язково
Обробка цього роута має включати:

Реєстрацію роута в файлі src/routers/users.js
Валідацію отриманих даних
Опис контролера для цього роута в файлі src/controllers/users.js
Створення сервісу в файлі src/services/users.js

Переконайтеся, що користувач із такою поштою ще не існує в системі, поверніть за допомогою бібілотеки createHttpError 409 помилку в іншому випадку і повідомлення 'Email in use’.

Відповідь сервера, в разі успішного створення нового користувача, має бути зі статусом 201 і містити об’єкт з наступними властивостями:

status — статус відповіді
message — повідомлення про результат виконання операції "Successfully registered a user!"
data — дані створеного користувача

TASK 4
Створіть роут POST /users/login для аутентифікації користувача. Тіло запиту має в себе включати наступні властивості:

email - обовʼязково
password - обовʼязково
Обробка цього роута має включати:

Реєстрацію роута в файлі src/routers/users.js
Валідацію отриманих даних
Опис контролера для цього роута в файлі src/controllers/users.js
Створення сервісу в файлі src/services/users.js

Переконайтеся, що користувач із такою поштою та паролем існує в системі, поверніть за допомогою бібліотеки createHttpError 401 помилку в іншому випадку.

Якщо користувача за переданими даними було знайдено, то створіть для нього сессію, в яку запишіть згенеровані access та refresh токени. Стара сесія, за її наявності, має бути видалена. Вкажіть час життя 15 хв для access токену та 30 днів для refresh токену.

Запишіть рефреш токен в cookies, а access токен поверніть в тілі відповіді.

Відповідь сервера, в разі успішного логіну, має бути зі статусом 200 і містити об’єкт з наступними властивостями:

status — статус відповіді
message — повідомлення про результат виконання операції "Successfully logged in an user!"
data — об'єкт з властивістю accessToken, що містить значення створеного access токена

TASK 5
Розширте модель Product обовʼязковим полем userId, яке буде вказувати на приналежність продукта певному користувачу.

Змініть логіку роута POST /products, щоб при створенні нового продукту також додавалося поле userId. Значення для userId візьміть із req.user.\_id.

Також змініть логіку для всіх інших роутів, які працюють з колекцією продуктів, щоб користувачі могли працювати лише з власними продуктами. Для цього у сервісних функціях використовуйте методи Mongoose такі як find(), findOne() тощо, щоб мати можливість шукати продукти окрім іншого і за значенням властивості userId.

TASK 6
Створіть middleware authenticate, який буде на основі access токену з заголовку Authorization у вигляді Bearer-токену, визначати користувача і додавати його до обʼєкту запиту(req) у вигляді властивості user. При цьому переконайтеся, що access токен не протермінований, інакше за допомогою бібліотеки createHttpError поверніть помилку зі статусом 401 і повідомленням “Access token expired”.

Застосуйте цей middleware до всіх роутів продуктів, щоб користувачі могли взаємодіяти тільки з власною колекцією продуктів.

TASK 7
Створіть роут POST /users/logoutдля видалення сесії на основі id сесії та токена, який записаний в cookies.

Обробка цього роута має включати:

Реєстрацію роута в файлі src/routers/users.js
Опис контролера для цього роута в файлі src/controllers/users.js
Створення сервісу в файлі src/services/users.js
Поточна сесія має бути видалена.
Відповідь сервера, в разі успішного логаута, має бути зі статусом 204, без тіла відповіді.

TASK 8
Створіть роут POST /users/refresh для оновлення сесії на основі рефреш токена, який записаний в cookies.

Обробка цього роута має включати:

Реєстрацію роута в файлі src/routers/users.js
Опис контролера для цього роута в файлі src/controllers/users.js
Створення сервісу в файлі src/services/users.js
Попередня сесія, за її наявності, має бути видалена, а нова створена за тим самим принципом, що і в POST /users/login.
Відповідь сервера, в разі успішного створення нового продукту, має бути зі статусом 200 і містити об’єкт з наступними властивостями:
status — статус відповіді
message — повідомлення про результат виконання операції "Successfully refreshed a session!"
data — об'єкт з властивістю accessToken, що містить значення новоствореного access токена
